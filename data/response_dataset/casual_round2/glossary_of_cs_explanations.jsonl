{"Major": "Computer Science", "Term": "quantum computing", "Explanation": "- Definition: quantum computing is a way of using tiny quantum particles to process information in ways that can be much faster for some problems.\n- Real-life analogy: It's like a search tool that can check many possible answers at once and then highlight the best one.\n- Concrete example: For factoring large numbers, a quantum computer could use Shor's algorithm, a method that factors big numbers quickly, potentially weakening today’s encryption.\n- Takeaway: it's a powerful new tool for hard problems, giving speedups for specific tasks but not a universal upgrade for all computing."}
{"Major": "Computer Science", "Term": "big O notation", "Explanation": "- Definition: big O notation is a simple way to describe how the time or space an algorithm uses grows as the input gets bigger.\n- Real-life analogy: imagine searching for a page in a long book by flipping pages from the start; as the book length grows, the number of flips grows in a predictable way.\n- Concrete example: if you check each item in a list until you find the one you want, you might have to look through all n items in the worst case, which is O(n).\n- Takeaway: knowing this helps you choose faster designs and estimate which ideas will stay fast as data grows."}
{"Major": "Computer Science", "Term": "semantics", "Explanation": "- Definition: Semantics is the meaning of code—the behavior that happens when the program runs.\n- Real-life analogy: Like a recipe—the words are the steps, semantics is the finished cake you actually bake.\n- Concrete example: For example, in Python, print(2 + 3) uses semantics to display the number 5.\n- Takeaway: Semantics is what your code means in action; knowing it helps you predict, reason about, and trust what your programs will do."}
{"Major": "Computer Science", "Term": "floating-point arithmetic", "Explanation": "- Definition: Floating-point arithmetic is how computers store and do math with numbers that have decimals by using a format similar to scientific notation.\n\n- Real-life analogy: Think of it like a ruler with limited marks—great for most measurements, but you can't be perfectly exact for every length; you get approximate results.\n\n- Concrete example: In many languages, 0.1 + 0.2 is not exactly 0.3; you might see 0.30000000000000004 because the decimal 0.1 and 0.2 don't have exact binary representations.\n\n- Takeaway: small rounding errors are normal; they can pile up. Don’t rely on exact equality for floats; use rounding or specialized math libraries when you need precise comparisons or results."}
{"Major": "Computer Science", "Term": "quicksort", "Explanation": "- Definition: quicksort is a simple method for sorting things by choosing a pivot (an item to split the rest into smaller and bigger groups) and then sorting the left and right sides the same way.\n\n- Real-life analogy: it’s like sorting a pile of coins by picking one coin as a divider and sliding smaller coins to the left and larger ones to the right, then repeating on each side.\n\n- Concrete example: with [3, 6, 2, 7, 4], pick 3 as pivot, split into left [2] and right [6, 7, 4], sort those parts recursively to end with [2, 3, 4, 6, 7].\n\n- Takeaway: quicksort is fast and scalable in practice because you sort pieces independently after a pivot split, a simple idea that helps handle large lists."}
{"Major": "Computer Science", "Term": "agent-based model (ABM)", "Explanation": "- Definition: An agent-based model (ABM) is a way to study a system by simulating many small decision-makers (agents) who interact with each other and with their surroundings.\n\n- Real-life analogy: Think of a crowd at a festival: each person moves and reacts in small ways, and the whole crowd’s flow shapes itself.\n\n- Concrete example: simulate traffic where each car slows, speeds, and changes lanes based on nearby cars; you can see how jams form from simple rules.\n\n- Takeaway: ABMs reveal how big patterns arise from many little decisions, and let you test ideas safely before trying them in the real world."}
{"Major": "Computer Science", "Term": "big data", "Explanation": "- Definition: big data is information so large and complex that normal software struggles to process it quickly.\n- Real-life analogy: It’s like trying to drink from a fire hose—the data pours in fast and in huge amounts.\n- Concrete example: Think of a popular streaming service collecting billions of viewing events per day to spot trends and personalize suggestions. \n- Takeaway: The point is scale changes the game, so you need special tools and strategies to turn vast data into useful decisions."}
{"Major": "Computer Science", "Term": "class", "Explanation": "- Definition: A class is a blueprint for making objects in a program; it describes what information the objects hold and what actions they can perform.\n- Real-life analogy: It's like a car-model blueprint: it says what a car of that model will have (color, features) and what it can do (drive, honk); from the blueprint you can build many actual cars.\n- Concrete example: class Car with attributes color, model, year; methods drive(), honk(). Create myCar with color red, model Civic, year 2020; call myCar.drive().\n- Takeaway: Classes help organize code and make many similar objects quickly—define once, reuse many times."}
{"Major": "Computer Science", "Term": "coding theory", "Explanation": "- Definition: Coding theory is the study of how to encode information so it can be sent or stored reliably even when there’s noise or damage.\n- Real-life analogy: It’s like sending a message in a noisy room and adding little hints so the listener can reconstruct the exact words even if some sounds blend together.\n- Concrete example: QR codes use error-correcting codes; if part of the pattern is scratched, the scanner still recovers the original data.\n- Takeaway: It matters because it makes our digital world robust—emails, streaming, hard drives, and satellites can survive glitches with smarter encoding."}
{"Major": "Computer Science", "Term": "computability theory", "Explanation": "- Definition: computability theory asks which problems can be solved by a computer using a clear, finite set of steps.\n\n- Real-life analogy: Think of a recipe that tells you every step to finish a dish; computability asks which questions have such a workable recipe.\n\n- Concrete example: The Halting Problem shows there is no universal recipe that can decide, for every program and input, whether the program will ever stop running.\n\n- Takeaway: It tells us the true limits of what we can automate and solve with algorithms."}
