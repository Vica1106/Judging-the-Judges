{"Major": "Computer Science", "Term": "quantum computing", "Explanation": "Quantum computing is a different kind of computer that uses the weird rules of quantum physics. Instead of regular bits that are either 0 or 1, quantum computers use qubits that can be 0, 1, or both at once. This lets them explore many possibilities at the same time.\n\nAnalogy: imagine you’re trying to find a shortcut through a giant maze. A normal computer checks paths one by one. A quantum computer can kind of consider many paths at once, then helps you zero in on the right route. It’s not magic—just a different kind of math under the hood.\n\nThey aren’t faster at everything. They’re really good for certain tricky problems, like simulating how molecules behave or solving very hard optimization puzzles. Right now they’re still experimental and need special, super-cold hardware to keep the qubits from getting messy.\n\nBottom line: quantum computing is a new tool for specific kinds of problems, not a replacement for regular computers."}
{"Major": "Computer Science", "Term": "big O notation", "Explanation": "Big O notation is a way to describe how the amount of work a program has to do grows as the amount of data grows.\n\nAnalogy: think of cleaning a room. If you add more stuff, it takes longer, roughly in proportion to how much stuff there is.\n\nCommon ideas:\n- O(1): constant time. The task doesn’t get harder as the data grows (e.g., grabbing the first item).\n- O(n): work grows linearly with data (e.g., checking every item in a list).\n- O(n^2): work grows with the square of the data (e.g., comparing every item to every other item).\n- O(log n): work grows slowly, cutting the problem in half each step (e.g., binary search in a sorted list).\n\nExamples:\n- Finding your name in an unsorted list: O(n).\n- Binary search in a sorted list: O(log n).\n- Sorting a list: usually around O(n log n) in many common algorithms.\n\nNote: Big O focuses on how time (or space) grows with big inputs, mainly the worst case, and helps you compare how efficient different approaches are as data scales."}
{"Major": "Computer Science", "Term": "semantics", "Explanation": "Semantics in computer science is the meaning behind the code: what it actually does when you run it. Syntax is just the rules for writing it—the shapes and punctuation. Semantics is about the results and behavior.\n\nAnalogy: think of a recipe. The words on the page are the syntax; the final dish and how it turns out is the semantics—the actual thing you end up with.\n\nExamples:\n- x = 2 + 3 — the semantics are: compute 2+3 and store the value 5 in x.\n- print('hi') — the semantics are: display the text hi on the screen.\n\nSo semantics answers questions like: What value does x hold? What happens when this line runs? Different languages can have slightly different semantics, even for similar-looking lines, so semantics is what you need to understand to know what a program will actually do."}
{"Major": "Computer Science", "Term": "floating-point arithmetic", "Explanation": "Floating-point arithmetic is how computers handle real numbers (those with decimals) when they only have a fixed amount of space to store them.\n\nThink of it like writing numbers in scientific notation, but with only a few digits to work with. For example, you might store something like 1.23 × 10^4, but if your space only fits 3–4 digits, you’d store a rounded version like 1.23 × 10^4 or 1.24 × 10^4. That means not every real number can be represented exactly; the computer rounds to the closest representable value.\n\nBecause of that rounding, math on a computer can introduce tiny errors. Those errors can add up in long calculations or bite you when you subtract nearly equal numbers. There are also edge cases with really big or really small results (and sometimes special values like “infinity”).\n\nSo, floating-point arithmetic is a practical way for computers to do real-number math quickly, trading perfect precision for speed and consistency across different calculations."}
{"Major": "Computer Science", "Term": "quicksort", "Explanation": "Quicksort is a fast way to sort a list. Imagine sorting a deck of playing cards. Pick one card as the pivot. Look at the rest and put all cards smaller than the pivot into a left pile and all bigger cards into a right pile. Put the pivot between the two piles. Now sort the left pile and the right pile the same way: pick a pivot in that pile, split it into two smaller piles, and keep going. When a pile has 0 or 1 cards, it’s already sorted. Finally, stack the left pile, then the pivot, then the right pile to get the whole list in order. The trick is you keep breaking the problem into smaller pieces and then combine them. On average, quicksort runs in about n log n steps. In the worst case (if your pivots are always the smallest or largest), it can slow down to n^2."}
{"Major": "Computer Science", "Term": "agent-based model (ABM)", "Explanation": "ABM stands for agent-based model. It’s a way to study big, messy systems by simulating lots of tiny decision-makers.\n\nIn an ABM you create many “agents” (think virtual people or cars). Each agent has a few simple rules and its own little state (like where it is and what it’s trying to do). They act based on their own situation and what nearby agents or the environment look like. There’s no central boss telling everyone what to do. You start the model, watch how things unfold over time, and see if interesting patterns show up.\n\nOne simple analogy: a crowd at a festival. Each person decides where to go next using simple rules (stick with friends, head toward a concert or exit, dodge obstacles). No one has the whole map, but together their tiny decisions create real patterns like crowd flow and bottlenecks.\n\nABMs are useful for exploring “what if” scenarios in things like traffic, disease spread, or how ideas spread in a community."}
{"Major": "Computer Science", "Term": "big data", "Explanation": "Big data is a way of talking about data that’s so big, fast, and varied that ordinary tools can’t handle it easily.\n\nOne simple real-life analogy: imagine trying to drink from a firehose. there’s so much water rushing at you that you need special gear and smart tricks to keep up and understand what’s happening.\n\nIn practice, people collect data from lots of places—websites, apps, sensors, social media, transactions—and it comes in different kinds: clicks, photos, numbers, messages. With big data, you don’t just store it; you analyze it to find patterns, spot trends, or detect unusual things. Companies use it to tailor recommendations, prevent problems, and improve services. It’s not just about how much data you have, but about how you use smart tools to turn that flood of information into useful insights."}
{"Major": "Computer Science", "Term": "class", "Explanation": "Class is a blueprint for a type of thing in code. It doesn’t do anything by itself, but it defines what that thing is like (its properties) and what it can do (its actions).\n\nAnalogy: it’s like a cookie recipe. The recipe lists ingredients and steps. Each batch you bake is an instance of that recipe—the cookies you pull out have their own flavor, color, and shape, but they all followed the same plan.\n\nIn code terms, you define a class with attributes (things it has) and methods (things it can do). Then you create objects (instances) from that class, each with its own data.\n\nExample (very simple, Python-like):\nclass Dog:\n  def __init__(self, name):\n    self.name = name\n  def bark(self):\n    print(\"Woof\")\n\nmy_dog = Dog(\"Rex\")\nmy_dog.bark()\n\nYou can make many dogs from the same class, each with its own name, but they all know how to bark."}
{"Major": "Computer Science", "Term": "coding theory", "Explanation": "Coding theory is the part of computer science that asks: how can we send or store messages so mistakes don’t ruin them? The idea is to add a little extra information when you send data. If some bits get garbled or part of the storage gets damaged, those extra clues help the receiver figure out what was really meant, and sometimes fix the mistakes right away.\n\nOne simple analogy: it’s like writing a message with tiny hints that survive a rough ride through a noisy line. Even if some words get smeared or lost, the hints let your friend understand the message anyway.\n\nWhere it helps: designing methods that can detect and fix mistakes, figuring out how much extra data to add, and making things like wireless sends, CDs/DVDs, and QR codes more reliable."}
{"Major": "Computer Science", "Term": "computability theory", "Explanation": "Computability theory is the branch of computer science that asks which problems can be solved by a step-by-step procedure (an algorithm) and which can’t, no matter how you try. It’s not about speed or memory, just whether there exists a fixed recipe that always gives an answer.\n\nAnalogy: imagine a robot cook. You want a recipe that, for any kitchen question you throw at it, will say yes it’s doable or no it isn’t, and then actually follow the steps to finish. For some questions there is such a recipe; for others there isn’t. A famous example is the Halting problem: will a given recipe finish running or go on forever? There’s no universal recipe that can answer that for every possible program.\n\nSome tasks are solvable by a recipe—like sorting a list or finding a square root. Others aren’t. Computability theory helps us tell the difference."}
